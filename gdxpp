#!/usr/bin/env python

import argparse
import colorama
import glob
import io
import os
import pathlib
import subprocess
import sys

from libgdxpp.opts import Opts
from libgdxpp.platform import Platform
from libgdxpp.stdio import *
from libgdxpp.which import which

print_debug('Starting gdxpp...')

parser = argparse.ArgumentParser(
    allow_abbrev=False,
    description='Environment and Build Manager for C++ GDExtensions',
    prog='gdxpp',
    suggest_on_error=True,
)

subparsers = parser.add_subparsers(
    dest='subcommand',
    required=True
)

parser_build = subparsers.add_parser(
    'build',
    help='build GDExtensions and dependencies'
)
parser_build.add_argument('-c', '--cores', type=int, default=0, help='number of logical cores to build with, by default 75%% of what is available but at least 1 (recommended to be below your total core count so you can still use your computer!)')
parser_build.add_argument('--debug-symbols', action=argparse.BooleanOptionalAction, default=True, help='if debug symbols should be included, default true')
parser_build.add_argument('--dev-build', action=argparse.BooleanOptionalAction, help='if the build should be dev mode')
parser_build.add_argument('--exceptions', action=argparse.BooleanOptionalAction, default=True, help='if C++ exceptions should be enabled, default true')
parser_build.add_argument('-o', '--output', type=pathlib.Path, default='project/extensions', help='the extensions output directory, default "<cwd>/project/extensions"')
parser_build.add_argument('-p', '--platform', type=Platform, choices=Platform.get_available_choices(), help='the platform to compile for (allows cross-compilation), defaults to the current system')
parser_build.add_argument('--skip-godot-cpp', action=argparse.BooleanOptionalAction, default=False, help='if godot-cpp should be compiled before the extensions (by default it will be)')
parser_build.add_argument('-t', '--target', choices=['debug', 'release'], default='debug', help='the Godot build template to use, default release (debug and release are shorthand for template_debug and template_release respectively)')
parser_build.add_argument('--use-hot-reload', action=argparse.BooleanOptionalAction, help="whether or not to enable hot reloading of the binaries, on by default for debug and off by default for release")
parser_build.add_argument('--use-llvm', action=argparse.BooleanOptionalAction, default=True, help='if LLVM should be used as the compiler (default true)')
parser_build.add_argument('--use-mingw', action=argparse.BooleanOptionalAction, default=True, help="whether or not to use MinGW, only has an effect on Windows")
parser_build.add_argument('--use-static-cpp', action=argparse.BooleanOptionalAction, help="whether or not to statically link libgcc/libstdc++ for portability, off by default for debug and on by default for release")

parser_prepare = subparsers.add_parser(
    'prepare',
    help='prepare the local environment for building GDExtensions and running the project'
)

parser_run = subparsers.add_parser(
    'run',
    help='run the project in the Godot editor or player'
)
parser_run.add_argument('-e', '--editor', action='store_true', help='if the Godot editor should be launched (by default the player will be launched)')
parser_run.add_argument('-p', '--project-path', type=pathlib.Path, default='project/project.godot', help='the path to the project.godot file, default "<cwd>/project/project.godot"')
parser_run.add_argument('-v', '--verbose', action='store_true', help='if the --verbose flag should be passed to Godot (default false)')

opts: Opts = parser.parse_args(namespace=Opts())
opts.validate()

path_repo_root = pathlib.Path().resolve()
path_output = path_repo_root.joinpath('extensions')
path_config_godot_executable_name = path_repo_root.joinpath('.godot-path')

godot_executable_name = 'godot'
if path_config_godot_executable_name.exists():
    try:
        godot_executable_name = open(path_config_godot_executable_name, 'r').read().strip()
        print_debug('Godot executable name is "%s"' % godot_executable_name)
    except:
        print_warning('Unable to read an executable name from .godot-path')
else:
    print_debug('.godot-path does not exist, falling back to "godot" as the executable name/path...')

path_godot_executable = which(godot_executable_name)
if not path_godot_executable:
    print_error('Unable to find the godot executable, is .godot-path an invalid path or does it not exist?')

path_repo_root = pathlib.Path().resolve()
path_vendor = path_repo_root.joinpath('vendor')
path_vendor_godot_cpp = path_vendor.joinpath('godot-cpp')

match opts.subcommand:
    case "build":
        scons_args = [
            "-j%d" % opts.cores,
            "debug_symbols=%s" % ("yes" if opts.debug_symbols else "no"),
            "dev_build=%s" % ("yes" if opts.dev_build else "no"),
            # "disable_exceptions=%s" % ("no" if opts.exceptions else "yes"),
            "platform=%s" % opts.platform.value,
            "target=%s" % opts.target,
            "use_hot_reload=%s" % ("yes" if opts.use_hot_reload else "no"),
            "use_llvm=%s" % ("yes" if opts.use_llvm else "no"),
            "use_mingw=%s" % ("yes" if opts.use_mingw else "no"),
            "use_static_cpp=%s" % ("yes" if opts.use_static_cpp else "no"),
        ]

        if opts.platform == Platform.Windows:
            scons_args += ["use_mingw=%s" % ("yes" if opts.use_mingw else "no")]

        if opts.skip_godot_cpp:
            print_notice('Skipping godot-cpp build due to command line option...', dim=True)
        else:
            godot_cpp_scons_args = [
                *scons_args,
                'custom_api_file=%s' % pathlib.Path('').joinpath('..', '..', 'extension_api.json')
            ]

            try:
                print_debug('Building godot-cpp with "scons', *godot_cpp_scons_args, '" in "%s"...' % path_vendor_godot_cpp)
                godot_cpp_scons_process = subprocess.Popen(
                    [
                        'scons',
                        *godot_cpp_scons_args,
                    ],
                    encoding='utf-8',
                    cwd=path_vendor_godot_cpp,
                )
                godot_cpp_scons_ret = godot_cpp_scons_process.wait()
                if godot_cpp_scons_ret != 0:
                    print_error('scons exited with code ', godot_cpp_scons_ret)
                    exit(3)
            except Exception as err:
                print_error('Error occurred building godot-cpp: ', err)
                exit(-3)

        try:
            extensions_scons_args = [
                *scons_args,
                'path_project=%s' % opts.output,
            ]
            print_debug('Building extensions with "scons', *extensions_scons_args, '" in "%s"...' % path_repo_root)
            extensions_scons_process = subprocess.Popen(
                [
                    'scons',
                    *extensions_scons_args,
                ],
                encoding='utf-8',
                cwd=path_repo_root
            )
            extensions_scons_ret = extensions_scons_process.wait()
            if extensions_scons_ret != 0:
                print_error('scons exited with code %d' % extensions_scons_ret)
                exit(4)
        except Exception as err:
            print_error('Error occurred building extensions: ', err)
            exit(-4)

        try:
            print_notice('Checking for linker errors...')

            path_output_bin_glob = str(path_output.joinpath('*', 'bin', '*'))
            relative_file_paths = glob.glob(path_output_bin_glob)
            resolved_file_paths = map(lambda f: path_output.joinpath(f), relative_file_paths)

            linker_errors = 0

            for resolved_file_path in resolved_file_paths:
                file_extensions = resolved_file_path.suffixes
                for file_extension in file_extensions:
                    match file_extension:
                        case '.a':
                            pass

                        case '.wasm':
                            pass

                        case '.so':
                            ldd_args = [
                                'ldd',
                                '-d',
                                '-r',
                                str(resolved_file_path)
                            ]
                            print_notice('\tCalling "%s"...' % ' '.join(ldd_args), dim=True)
                            ldd_process = subprocess.Popen(
                                ldd_args,
                                encoding='utf-8',
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                cwd=path_repo_root,
                            )
                            ldd_out, ldd_err = ldd_process.communicate()
                            ldd_return = ldd_process.returncode

                            if ldd_return != 0:
                                print_error('ldd -d -r %s exited with code %d:\n%s' % (
                                    resolved_file_path,
                                    ldd_return,
                                    indent_lines(ldd_err)
                                ))
                                linker_errors += 1
                            else:
                                ldd_err_lines = ldd_err.splitlines()
                                undefined_symbol_lines = [
                                    l for l in ldd_err_lines
                                    if 'undefined symbol:' in l
                                ]
                                count_undefined_symbol_lines = len(undefined_symbol_lines)
                                if len(undefined_symbol_lines) > 0:
                                    linker_errors += count_undefined_symbol_lines
                                    relative_file_path = resolved_file_path.relative_to(path_repo_root)
                                    print_error('\t[FATAL] Found undefined symbols in %s:%s%s' % (
                                        relative_file_path,
                                        os.linesep,
                                        os.linesep.join(indent_lines(undefined_symbol_lines))
                                    ))

            if linker_errors > 0:
                print_error('\t[FATAL] Found %d linker errors' % ldd_return)
                exit(5)

            print_success('\tNo linker errors found', dim=True)

            print_success('Build successful')

        except Exception as err:
            print_error('Error occurred checking for linker errors: ', err)
            exit(-5)

    case "prepare":
        print_notice('Preparing project in "%s"...' % path_repo_root)

        command_git_submodule_update_init_recursive = 'git submodule update --init --recursive'
        try:
            print_notice('Ensuring vendor submodules are properly initialized...', dim=True)
            output = subprocess.check_output(
                command_git_submodule_update_init_recursive.split(' '),
                cwd=path_repo_root,
                encoding='utf-8'
            )
            output_lines = output.splitlines(keepends=False)
            print_debug(*map(lambda line: '\t' + line, output_lines), sep=linesep)
        except subprocess.CalledProcessError as called_process_error:
            print_error('\t%s' % called_process_error)
            exit(3)
        except Exception as err:
            print_error('Unexpected error updating submodules: %s' % err)
            exit(-3)

        try:
            print_notice('Dumping extension_api.json into repository root...', dim=True)
            output = subprocess.check_output(
                [path_godot_executable, '--headless', '--dump-extension-api'],
                cwd=path_repo_root,
                encoding='utf-8'
            )
            output_lines = output.splitlines(keepends=False)
            print_debug(*map(lambda line: '\t' + line, output_lines), sep=linesep)
        except subprocess.CalledProcessError as called_process_error:
            print_error('\t%s' % called_process_error)
            exit(4)
        except Exception as err:
            print_error('Unexpected error dumping extension_api.json into repository root: %s' % err)
            exit(-4)

        try:
            print_notice('Dumping extension_api.json and gdextension_interface.h into vendor/godot-cpp...', dim=True)
            output = subprocess.check_output(
                [path_godot_executable, '--headless', '--dump-extension-api', '--dump-gdextension-interface'],
                cwd=path_vendor_godot_cpp,
                encoding='utf-8'
            )
            output_lines = output.splitlines(keepends=False)
            print_debug(*map(lambda line: '\t' + line, output_lines), sep=linesep)
        except subprocess.CalledProcessError as called_process_error:
            print_error('\t%s' % called_process_error)
            exit(5)
        except Exception as err:
            print_error('Unexpected error dumping extension_api.json and gdextension_interface.h into vendor/godot-cpp: %s' % err)
            exit(-5)

        try:
            print_notice('Creating a symlink for Godot...', dim=True)
            path_godot_symlink = path_repo_root.joinpath('godot')
            if path_godot_symlink.exists():
                if path_godot_symlink.resolve() == path_godot_executable:
                    print_debug('\tSkipping because the symlink exists and already points where it should')
                else:
                    path_godot_symlink.unlink(missing_ok=True)
                    os.symlink(path_godot_executable, path_repo_root.joinpath('godot'))
            else:
                os.symlink(path_godot_executable, path_repo_root.joinpath('godot'))
        except Exception as err:
            print_error('Unexpected error dumping extension_api.json and gdextension_interface.h into vendor/godot-cpp: %s' % err)
            exit(-6)

        print_success('Successfully completed repository preparation')

    case "run":
        pass
